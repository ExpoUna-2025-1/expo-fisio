import cv2
import mediapipe as mp
import math
import time

def calcular_angulo(a, b, c):
    ba = (a[0] - b[0], a[1] - b[1])
    bc = (c[0] - b[0], c[1] - b[1])
    dot_product = ba[0]*bc[0] + ba[1]*bc[1]
    norm_ba = math.hypot(*ba)
    norm_bc = math.hypot(*bc)

    if norm_ba * norm_bc == 0:
        return 0

    angle_rad = math.acos(max(min(dot_product / (norm_ba * norm_bc), 1.0), -1.0))
    return math.degrees(angle_rad)

def suavizar_pontos(novos, antigos, alpha=0.5):
    if antigos is None:
        return novos
    return [(int(alpha*n[0] + (1-alpha)*a[0]), int(alpha*n[1] + (1-alpha)*a[1])) for n, a in zip(novos, antigos)]

mp_pose = mp.solutions.pose
pose = mp_pose.Pose(
    static_image_mode=False,
    model_complexity=2,
    smooth_landmarks=True,
    min_detection_confidence=0.7,
    min_tracking_confidence=0.7
)

video = cv2.VideoCapture("video.mp4")

prev_points = None
detected_last_frame = False
prev_time = 0
ultimo_angulo = None  # Novo: guardar o último ângulo válido

while video.isOpened():
    ret, frame = video.read()
    if not ret:
        break

    frame = cv2.convertScaleAbs(frame, alpha=1.2, beta=20)
    h, w, _ = frame.shape
    rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    resultado = pose.process(rgb)

    if resultado.pose_landmarks:
        landmarks = resultado.pose_landmarks.landmark
        pontos_ids = [24, 26, 28]  # quadril, joelho, tornozelo
        pontos_visiveis = all(landmarks[i].visibility > 0.7 for i in pontos_ids)

        if pontos_visiveis:
            hip_xy = (int(landmarks[24].x * w), int(landmarks[24].y * h))
            knee_xy = (int(landmarks[26].x * w), int(landmarks[26].y * h))
            ankle_xy = (int(landmarks[28].x * w), int(landmarks[28].y * h))

            pontos_atual = [hip_xy, knee_xy, ankle_xy]
            if detected_last_frame:
                pontos_suavizados = suavizar_pontos(pontos_atual, prev_points)
            else:
                pontos_suavizados = pontos_atual

            prev_points = pontos_suavizados
            detected_last_frame = True

            cv2.line(frame, pontos_suavizados[0], pontos_suavizados[1], (50, 205, 50), 4)
            cv2.line(frame, pontos_suavizados[1], pontos_suavizados[2], (50, 205, 50), 4)

            angulo = calcular_angulo(pontos_suavizados[0], pontos_suavizados[1], pontos_suavizados[2])
            ultimo_angulo = int(180 - angulo)  # Atualiza o último ângulo válido
        else:
            prev_points = None
            detected_last_frame = False
    else:
        prev_points = None
        detected_last_frame = False

    # Mostra o último ângulo válido, mesmo se os pontos não forem detectados
    if ultimo_angulo is not None:
        cv2.putText(frame, f"{ultimo_angulo}°", (50, 100),
                    cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 0, 255), 3, cv2.LINE_AA)

    curr_time = time.time()
    fps = 1 / (curr_time - prev_time) if prev_time else 0
    prev_time = curr_time

    cv2.putText(frame, f"FPS: {int(fps)}", (20, 30),
                cv2.FONT_HERSHEY_SIMPLEX, 1, (200, 200, 200), 2)
    cv2.putText(frame, "Pressione ESC para sair", (20, h - 20),
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (180, 180, 180), 1)

    cv2.imshow("Angulo Joelho", frame)

    if cv2.waitKey(1) & 0xFF == 27:
        break

video.release()
cv2.destroyAllWindows()
